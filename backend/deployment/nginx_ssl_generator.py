#!/usr/bin/env python3
"""
Nginx SSL Configuration Generator
Generates secure Nginx configurations with SSL support for multiple domains
and applications with optimized security headers and SSL parameters.
"""

import os
import sys
import logging
import subprocess
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from pathlib import Path
from jinja2 import Template, Environment, FileSystemLoader
import yaml


@dataclass
class SSLSecurityConfig:
    """SSL security configuration parameters"""
    protocols: List[str] = field(default_factory=lambda: ['TLSv1.2', 'TLSv1.3'])
    ciphers: str = 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384'
    prefer_server_ciphers: bool = False
    session_cache: str = 'shared:SSL:10m'
    session_timeout: str = '10m'
    session_tickets: bool = False
    stapling: bool = True
    stapling_verify: bool = True
    hsts_max_age: int = 31536000
    hsts_include_subdomains: bool = True
    hsts_preload: bool = True


@dataclass
class ApplicationConfig:
    """Application-specific configuration"""
    name: str
    domain: str
    upstream_port: int
    root_path: Optional[str] = None
    index_files: List[str] = field(default_factory=lambda: ['index.html', 'index.htm'])
    client_max_body_size: str = '10M'
    proxy_timeout: int = 60
    static_locations: Dict[str, str] = field(default_factory=dict)
    custom_headers: Dict[str, str] = field(default_factory=dict)
    rate_limit: Optional[str] = None
    auth_required: bool = False


@dataclass
class NginxSSLConfig:
    """Main Nginx SSL configuration"""
    cert_path: str = '/etc/letsencrypt/live'
    nginx_path: str = '/etc/nginx'
    sites_available: str = '/etc/nginx/sites-available'
    sites_enabled: str = '/etc/nginx/sites-enabled'
    ssl_config: SSLSecurityConfig = field(default_factory=SSLSecurityConfig)
    applications: List[ApplicationConfig] = field(default_factory=list)
    default_server: bool = True
    access_log_format: str = 'combined'
    error_log_level: str = 'warn'


class NginxSSLGenerator:
    """
    Nginx SSL Configuration Generator
    
    Generates secure Nginx configurations with:
    - Multi-domain SSL support
    - Security headers and SSL parameter optimization
    - Application-specific configurations
    - Configuration file syntax validation
    """
    
    def __init__(self, config: NginxSSLConfig):
        self.config = config
        self.logger = self._setup_logger()
        self.template_env = self._setup_template_environment()
        
    def _setup_logger(self) -> logging.Logger:
        """Setup logging configuration"""
        logger = logging.getLogger(__name__)
        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logger.setLevel(logging.INFO)
        return logger
    
    def _setup_template_environment(self) -> Environment:
        """Setup Jinja2 template environment"""
        # Create templates directory if it doesn't exist
        template_dir = Path(__file__).parent / 'templates'
        template_dir.mkdir(exist_ok=True)
        
        # Create default templates if they don't exist
        self._create_default_templates(template_dir)
        
        return Environment(
            loader=FileSystemLoader(str(template_dir)),
            trim_blocks=True,
            lstrip_blocks=True
        )
    
    def _create_default_templates(self, template_dir: Path) -> None:
        """Create default Nginx configuration templates"""
        
        # Main SSL server template
        ssl_server_template = '''
# SSL Configuration for {{ app.domain }}
# Generated by Nginx SSL Generator

upstream {{ app.name }}_backend {
    server 127.0.0.1:{{ app.upstream_port }};
    keepalive 32;
}

# HTTP to HTTPS redirect
server {
    listen 80;
    server_name {{ app.domain }};
    
    # Security headers for HTTP
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options DENY;
    add_header X-XSS-Protection "1; mode=block";
    
    # Redirect all HTTP requests to HTTPS
    return 301 https://$server_name$request_uri;
}

# HTTPS server configuration
server {
    listen 443 ssl http2{% if default_server %} default_server{% endif %};
    server_name {{ app.domain }};
    
    # SSL Certificate Configuration
    ssl_certificate {{ cert_path }}/{{ app.domain }}/fullchain.pem;
    ssl_certificate_key {{ cert_path }}/{{ app.domain }}/privkey.pem;
    ssl_trusted_certificate {{ cert_path }}/{{ app.domain }}/chain.pem;
    
    # SSL Security Configuration
    ssl_protocols {{ ssl_config.protocols | join(' ') }};
    ssl_ciphers {{ ssl_config.ciphers }};
    ssl_prefer_server_ciphers {{ 'on' if ssl_config.prefer_server_ciphers else 'off' }};
    
    # SSL Session Configuration
    ssl_session_cache {{ ssl_config.session_cache }};
    ssl_session_timeout {{ ssl_config.session_timeout }};
    ssl_session_tickets {{ 'on' if ssl_config.session_tickets else 'off' }};
    
    {% if ssl_config.stapling %}
    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify {{ 'on' if ssl_config.stapling_verify else 'off' }};
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;
    {% endif %}
    
    # Security Headers
    add_header Strict-Transport-Security "max-age={{ ssl_config.hsts_max_age }}{% if ssl_config.hsts_include_subdomains %}; includeSubDomains{% endif %}{% if ssl_config.hsts_preload %}; preload{% endif %}" always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-Frame-Options DENY always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self'; frame-ancestors 'none';" always;
    
    {% for header, value in app.custom_headers.items() %}
    add_header {{ header }} "{{ value }}" always;
    {% endfor %}
    
    # Basic Configuration
    client_max_body_size {{ app.client_max_body_size }};
    
    # Logging
    access_log /var/log/nginx/{{ app.name }}_access.log {{ access_log_format }};
    error_log /var/log/nginx/{{ app.name }}_error.log {{ error_log_level }};
    
    {% if app.rate_limit %}
    # Rate Limiting
    limit_req zone={{ app.rate_limit }};
    {% endif %}
    
    {% if app.root_path %}
    # Static File Serving
    root {{ app.root_path }};
    index {{ app.index_files | join(' ') }};
    
    # Static file caching
    location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        add_header Vary Accept-Encoding;
        gzip_static on;
    }
    
    {% for location, path in app.static_locations.items() %}
    location {{ location }} {
        alias {{ path }};
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
    {% endfor %}
    
    # Main application location
    location / {
        try_files $uri $uri/ @backend;
    }
    
    location @backend {
        proxy_pass http://{{ app.name }}_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_connect_timeout {{ app.proxy_timeout }}s;
        proxy_send_timeout {{ app.proxy_timeout }}s;
        proxy_read_timeout {{ app.proxy_timeout }}s;
    }
    {% else %}
    # Reverse Proxy Configuration
    location / {
        proxy_pass http://{{ app.name }}_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_connect_timeout {{ app.proxy_timeout }}s;
        proxy_send_timeout {{ app.proxy_timeout }}s;
        proxy_read_timeout {{ app.proxy_timeout }}s;
    }
    {% endif %}
    
    {% if app.auth_required %}
    # Authentication
    auth_basic "Restricted Access";
    auth_basic_user_file /etc/nginx/.htpasswd;
    {% endif %}
    
    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
    
    # Security: Hide server information
    server_tokens off;
    
    # Security: Prevent access to hidden files
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }
}
'''
        
        ssl_template_path = template_dir / 'ssl_server.conf.j2'
        if not ssl_template_path.exists():
            ssl_template_path.write_text(ssl_server_template.strip())
        
        # Main Nginx configuration template
        main_config_template = '''
# Main Nginx Configuration
# Generated by Nginx SSL Generator

user www-data;
worker_processes auto;
pid /run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
    multi_accept on;
}

http {
    # Basic Settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    server_tokens off;
    
    # MIME Types
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    # Logging Settings
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                   '$status $body_bytes_sent "$http_referer" '
                   '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log {{ error_log_level }};
    
    # Gzip Settings
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;
    
    # Rate Limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;
    
    # SSL Settings
    ssl_protocols {{ ssl_config.protocols | join(' ') }};
    ssl_ciphers {{ ssl_config.ciphers }};
    ssl_prefer_server_ciphers {{ 'on' if ssl_config.prefer_server_ciphers else 'off' }};
    
    # Include site configurations
    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}
'''
        
        main_template_path = template_dir / 'nginx.conf.j2'
        if not main_template_path.exists():
            main_template_path.write_text(main_config_template.strip())
    
    def generate_ssl_configuration(self, app: ApplicationConfig) -> str:
        """
        Generate SSL configuration for a specific application
        
        Args:
            app: Application configuration
            
        Returns:
            Generated Nginx configuration as string
        """
        self.logger.info("Generating SSL configuration for application: %s", app.name)
        
        try:
            template = self.template_env.get_template('ssl_server.conf.j2')
            
            config = template.render(
                app=app,
                cert_path=self.config.cert_path,
                ssl_config=self.config.ssl_config,
                access_log_format=self.config.access_log_format,
                error_log_level=self.config.error_log_level,
                default_server=self.config.default_server and app == self.config.applications[0]
            )
            
            return config
            
        except Exception as e:
            self.logger.error("Error generating SSL configuration for %s: %s", app.name, str(e))
            raise
    
    def generate_main_configuration(self) -> str:
        """
        Generate main Nginx configuration
        
        Returns:
            Generated main Nginx configuration as string
        """
        self.logger.info("Generating main Nginx configuration")
        
        try:
            template = self.template_env.get_template('nginx.conf.j2')
            
            config = template.render(
                ssl_config=self.config.ssl_config,
                error_log_level=self.config.error_log_level
            )
            
            return config
            
        except Exception as e:
            self.logger.error("Error generating main Nginx configuration: %s", str(e))
            raise
    
    def write_configuration_files(self) -> Dict[str, bool]:
        """
        Write all configuration files to disk
        
        Returns:
            Dict mapping file paths to write success status
        """
        self.logger.info("Writing Nginx configuration files")
        results = {}
        
        try:
            # Ensure directories exist
            Path(self.config.sites_available).mkdir(parents=True, exist_ok=True)
            Path(self.config.sites_enabled).mkdir(parents=True, exist_ok=True)
            
            # Generate and write main configuration
            main_config = self.generate_main_configuration()
            main_config_path = Path(self.config.nginx_path) / 'nginx.conf'
            
            # Backup existing configuration
            if main_config_path.exists():
                backup_path = main_config_path.with_suffix('.conf.backup')
                backup_path.write_text(main_config_path.read_text())
                self.logger.info("Backed up existing nginx.conf to %s", backup_path)
            
            main_config_path.write_text(main_config)
            results[str(main_config_path)] = True
            self.logger.info("Written main configuration to %s", main_config_path)
            
            # Generate and write application configurations
            for app in self.config.applications:
                app_config = self.generate_ssl_configuration(app)
                
                # Write to sites-available
                available_path = Path(self.config.sites_available) / f"{app.name}.conf"
                available_path.write_text(app_config)
                results[str(available_path)] = True
                
                # Create symlink in sites-enabled
                enabled_path = Path(self.config.sites_enabled) / f"{app.name}.conf"
                if enabled_path.exists() or enabled_path.is_symlink():
                    enabled_path.unlink()
                
                enabled_path.symlink_to(available_path)
                results[str(enabled_path)] = True
                
                self.logger.info("Written configuration for %s", app.name)
            
            return results
            
        except Exception as e:
            self.logger.error("Error writing configuration files: %s", str(e))
            raise
    
    def validate_configuration(self) -> bool:
        """
        Validate Nginx configuration syntax
        
        Returns:
            True if configuration is valid
        """
        self.logger.info("Validating Nginx configuration")
        
        try:
            result = subprocess.run(
                ['nginx', '-t'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                self.logger.info("Nginx configuration validation successful")
                self.logger.info("Validation output: %s", result.stdout)
                return True
            else:
                self.logger.error("Nginx configuration validation failed")
                self.logger.error("Validation error: %s", result.stderr)
                return False
                
        except subprocess.TimeoutExpired:
            self.logger.error("Nginx configuration validation timed out")
            return False
        except FileNotFoundError:
            self.logger.error("Nginx binary not found")
            return False
        except Exception as e:
            self.logger.error("Error validating Nginx configuration: %s", str(e))
            return False
    
    def reload_nginx(self) -> bool:
        """
        Reload Nginx configuration
        
        Returns:
            True if reload was successful
        """
        self.logger.info("Reloading Nginx configuration")
        
        try:
            # First validate configuration
            if not self.validate_configuration():
                self.logger.error("Cannot reload Nginx: configuration validation failed")
                return False
            
            # Reload Nginx
            result = subprocess.run(
                ['systemctl', 'reload', 'nginx'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                self.logger.info("Nginx reload successful")
                return True
            else:
                self.logger.error("Nginx reload failed: %s", result.stderr)
                return False
                
        except subprocess.TimeoutExpired:
            self.logger.error("Nginx reload timed out")
            return False
        except Exception as e:
            self.logger.error("Error reloading Nginx: %s", str(e))
            return False
    
    def deploy_configurations(self) -> bool:
        """
        Deploy all configurations and reload Nginx
        
        Returns:
            True if deployment was successful
        """
        self.logger.info("Deploying Nginx SSL configurations")
        
        try:
            # Write configuration files
            write_results = self.write_configuration_files()
            
            # Check if all files were written successfully
            failed_files = [path for path, success in write_results.items() if not success]
            if failed_files:
                self.logger.error("Failed to write configuration files: %s", failed_files)
                return False
            
            # Validate and reload Nginx
            if self.reload_nginx():
                self.logger.info("Nginx SSL configuration deployment successful")
                return True
            else:
                self.logger.error("Nginx SSL configuration deployment failed during reload")
                return False
                
        except Exception as e:
            self.logger.error("Error deploying Nginx SSL configurations: %s", str(e))
            return False
    
    def create_dhparam(self, key_size: int = 2048) -> bool:
        """
        Create Diffie-Hellman parameters for enhanced security
        
        Args:
            key_size: DH parameter key size
            
        Returns:
            True if DH parameters were created successfully
        """
        dhparam_path = Path(self.config.nginx_path) / 'dhparam.pem'
        
        if dhparam_path.exists():
            self.logger.info("DH parameters already exist at %s", dhparam_path)
            return True
        
        self.logger.info("Generating DH parameters (this may take a while)...")
        
        try:
            result = subprocess.run(
                ['openssl', 'dhparam', '-out', str(dhparam_path), str(key_size)],
                capture_output=True,
                text=True,
                timeout=600  # 10 minute timeout
            )
            
            if result.returncode == 0:
                # Set proper permissions
                os.chmod(dhparam_path, 0o644)
                self.logger.info("DH parameters generated successfully")
                return True
            else:
                self.logger.error("Failed to generate DH parameters: %s", result.stderr)
                return False
                
        except subprocess.TimeoutExpired:
            self.logger.error("DH parameter generation timed out")
            return False
        except Exception as e:
            self.logger.error("Error generating DH parameters: %s", str(e))
            return False


def load_config_from_file(config_file: str) -> NginxSSLConfig:
    """Load configuration from YAML file"""
    with open(config_file, 'r') as f:
        data = yaml.safe_load(f)
    
    # Parse SSL security config
    ssl_data = data.get('ssl_security', {})
    ssl_config = SSLSecurityConfig(**ssl_data)
    
    # Parse applications
    applications = []
    for app_data in data.get('applications', []):
        app = ApplicationConfig(**app_data)
        applications.append(app)
    
    # Parse main config
    main_data = data.copy()
    main_data.pop('ssl_security', None)
    main_data.pop('applications', None)
    main_data['ssl_config'] = ssl_config
    main_data['applications'] = applications
    
    return NginxSSLConfig(**main_data)


def main():
    """Main function for testing Nginx SSL generator"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Nginx SSL Configuration Generator')
    parser.add_argument('--config', help='Configuration file path')
    parser.add_argument('--domain', help='Domain name')
    parser.add_argument('--app-name', help='Application name')
    parser.add_argument('--port', type=int, default=8000, help='Upstream port')
    parser.add_argument('--root-path', help='Static files root path')
    parser.add_argument('--action', choices=['generate', 'deploy', 'validate'], 
                       default='generate', help='Action to perform')
    
    args = parser.parse_args()
    
    try:
        if args.config:
            # Load from configuration file
            config = load_config_from_file(args.config)
        else:
            # Create simple configuration from command line arguments
            if not args.domain or not args.app_name:
                print("Error: --domain and --app-name are required when not using --config")
                sys.exit(1)
            
            app = ApplicationConfig(
                name=args.app_name,
                domain=args.domain,
                upstream_port=args.port,
                root_path=args.root_path
            )
            
            config = NginxSSLConfig(applications=[app])
        
        # Create generator
        generator = NginxSSLGenerator(config)
        
        if args.action == 'generate':
            # Generate and print configurations
            print("=== Main Nginx Configuration ===")
            print(generator.generate_main_configuration())
            
            for app in config.applications:
                print(f"\n=== SSL Configuration for {app.name} ===")
                print(generator.generate_ssl_configuration(app))
                
        elif args.action == 'deploy':
            success = generator.deploy_configurations()
            print(f"Deployment: {'SUCCESS' if success else 'FAILED'}")
            
        elif args.action == 'validate':
            valid = generator.validate_configuration()
            print(f"Configuration: {'VALID' if valid else 'INVALID'}")
            
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()