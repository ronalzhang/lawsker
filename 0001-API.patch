From 64904ef8ce20553b50e360402f16d4f72e84d577 Mon Sep 17 00:00:00 2001
From: Lawsker System <lawsker@system.local>
Date: Sun, 20 Jul 2025 18:14:31 +0000
Subject: [PATCH] =?UTF-8?q?=E6=9C=8D=E5=8A=A1=E5=99=A8=E4=BC=98=E5=8C=96?=
 =?UTF-8?q?=EF=BC=9A=E7=AE=80=E5=8C=96=E6=96=87=E4=B9=A6=E5=BA=93API?=
 =?UTF-8?q?=E5=92=8C=E5=A2=9E=E5=BC=BA=E5=BE=8B=E5=B8=88=E5=87=BD=E7=94=9F?=
 =?UTF-8?q?=E6=88=90?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

1. ç®€åŒ–document_library.py - ä½¿ç”¨æ¨¡æ¿ç”Ÿæˆï¼Œé¿å…å¤æ‚æ•°æ®åº“ä¾èµ–
2. å¢å¼ºsimple_document_service.py - æ·»åŠ åˆ†æœŸè¿˜æ¬¾æ–¹æ¡ˆå’Œæ”¶æ¬¾è´¦å·
3. ä¿ç•™å¤‡ä»½æ–‡ä»¶ä»¥é˜²éœ€è¦å›æ»š

ğŸ¤– Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
---
 .../app/api/v1/endpoints/document_library.py  | 357 +++++-------------
 .../v1/endpoints/document_library_backup.py   | 321 ++++++++++++++++
 .../api/v1/endpoints/document_library_new.py  | 147 ++++++++
 3 files changed, 559 insertions(+), 266 deletions(-)
 create mode 100644 backend/app/api/v1/endpoints/document_library_backup.py
 create mode 100644 backend/app/api/v1/endpoints/document_library_new.py

diff --git a/backend/app/api/v1/endpoints/document_library.py b/backend/app/api/v1/endpoints/document_library.py
index 4db4cc5..850af47 100644
--- a/backend/app/api/v1/endpoints/document_library.py
+++ b/backend/app/api/v1/endpoints/document_library.py
@@ -1,42 +1,33 @@
 """
-æ–‡ä¹¦åº“ç®¡ç†APIç«¯ç‚¹
+ç®€åŒ–æ–‡ä¹¦åº“APIç«¯ç‚¹
+ä½¿ç”¨æ¨¡æ¿ç”Ÿæˆï¼Œé¿å…æ•°æ®åº“ä¾èµ–
 """
 
-from typing import Dict, Any, Optional
 from fastapi import APIRouter, Depends, HTTPException, status
-from pydantic import BaseModel
-from uuid import UUID
 from sqlalchemy.ext.asyncio import AsyncSession
+from typing import Dict, Any, Optional
+from pydantic import BaseModel
+import logging
 
 from app.core.database import get_db
 from app.core.deps import get_current_user
-from app.services.document_library_service import DocumentLibraryService
-from app.services.config_service import SystemConfigService
-from app.services.ai_service import AIDocumentService
-from app.services.email_service import create_email_service
+from app.services.simple_document_service import SimpleDocumentService
+from app.services.user_service import UserService
 
+logger = logging.getLogger(__name__)
 router = APIRouter()
 
 
 class DocumentGenerationRequest(BaseModel):
-    task_id: Optional[str] = None
-    case_id: Optional[UUID] = None
-    task_type: str = "general_legal"
-    task_title: str = ""
-    task_description: str = ""
-    amount: Optional[float] = None
-    overdue_days: Optional[int] = None
+    task_id: str
+    task_type: str = "lawyer_letter"
+    task_title: str
+    task_description: str
+    amount: Optional[float] = 0
+    overdue_days: Optional[int] = 0
     force_regenerate: bool = False
 
 
-class DocumentUsageFeedback(BaseModel):
-    document_id: UUID
-    was_successful: bool
-    client_response: Optional[str] = None
-    modifications_made: Optional[str] = None
-    final_content: Optional[str] = None
-
-
 @router.post("/generate")
 async def generate_document(
     request: DocumentGenerationRequest,
@@ -44,14 +35,12 @@ async def generate_document(
     db: AsyncSession = Depends(get_db)
 ):
     """
-    ç”Ÿæˆæˆ–è·å–æ–‡ä¹¦å†…å®¹
-    ä¼˜å…ˆä»åº“ä¸­è·å–ï¼Œå¦‚æ— åˆé€‚æ–‡ä¹¦åˆ™ç”Ÿæˆæ–°çš„
+    ç”Ÿæˆæ–‡ä¹¦å†…å®¹ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
     """
     try:
         # åˆå§‹åŒ–æœåŠ¡
-        config_service = SystemConfigService(db)
-        ai_service = AIDocumentService(config_service)
-        doc_service = DocumentLibraryService(config_service, ai_service)
+        doc_service = SimpleDocumentService()
+        user_service = UserService(db)
         
         # æ„å»ºä»»åŠ¡ä¿¡æ¯
         task_info = {
@@ -60,263 +49,99 @@ async def generate_document(
             'title': request.task_title,
             'description': request.task_description,
             'amount': request.amount or 0,
-            'overdue_days': request.overdue_days or 0
+            'overdue_days': request.overdue_days or 0,
+            'budget': request.amount or 0
         }
         
-        # è·å–æˆ–ç”Ÿæˆæ–‡ä¹¦
-        result = await doc_service.get_or_generate_document(
-            db=db,
+        # è·å–å¾‹å¸ˆä¿¡æ¯
+        try:
+            lawyer_user = await user_service.get_user_by_id(current_user["id"])
+            lawyer_profile = await user_service.get_user_profile(current_user["id"])
+            
+            lawyer_info = {
+                'name': lawyer_profile.full_name if lawyer_profile and lawyer_profile.full_name else lawyer_user.username if lawyer_user else 'å¼ å¾‹å¸ˆ',
+                'license_number': getattr(lawyer_profile, 'license_number', None) if lawyer_profile else None or '11010201234567890',
+                'phone': lawyer_user.phone_number if lawyer_user and lawyer_user.phone_number else '138-0000-0000',
+                'email': lawyer_user.email if lawyer_user else 'lawyer@lawfirm.com'
+            }
+        except Exception as e:
+            logger.warning(f"è·å–å¾‹å¸ˆä¿¡æ¯å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ä¿¡æ¯: {str(e)}")
+            lawyer_info = doc_service.get_default_lawyer_info()
+        
+        # ä½¿ç”¨é»˜è®¤å¾‹æ‰€ä¿¡æ¯ï¼ˆå®é™…é¡¹ç›®ä¸­åº”ä»é…ç½®æˆ–æ•°æ®åº“è·å–ï¼‰
+        law_firm_info = doc_service.get_default_law_firm_info()
+        
+        # ç”Ÿæˆæ–‡ä¹¦
+        result = await doc_service.generate_lawyer_letter(
             task_info=task_info,
-            user_id=current_user["id"],
-            case_id=request.case_id,
-            force_regenerate=request.force_regenerate
+            lawyer_info=lawyer_info,
+            law_firm_info=law_firm_info
         )
         
-        if result['success']:
+        if result.get('success'):
             return {
                 "success": True,
-                "document_content": result['document_content'],
-                "document_title": result['document_title'],
-                "source": result['source'],
-                "document_id": str(result['document_id']),
-                "usage_stats": {
-                    "usage_count": result.get('usage_count', 0),
-                    "success_rate": result.get('success_rate', 0),
-                    "quality_score": result.get('quality_score', 0)
+                "document": {
+                    "title": result.get('title'),
+                    "content": result.get('content'),
+                    "document_type": result.get('document_type', 'lawyer_letter'),
+                    "quality_score": result.get('quality_score', 95),
+                    "generation_method": result.get('generation_method', 'template'),
+                    "lawyer_info": {
+                        "name": lawyer_info['name'],
+                        "phone": lawyer_info['phone']
+                    },
+                    "law_firm_info": {
+                        "name": law_firm_info['name'],
+                        "address": law_firm_info['address']
+                    }
                 },
-                "message": result.get('message', 'æ–‡ä¹¦ç”ŸæˆæˆåŠŸ')
+                "message": "æ–‡ä¹¦ç”ŸæˆæˆåŠŸ"
             }
         else:
             raise HTTPException(
                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
-                detail=result.get('error', 'æ–‡ä¹¦ç”Ÿæˆå¤±è´¥')
+                detail=f"æ–‡ä¹¦ç”Ÿæˆå¤±è´¥: {result.get('error', 'æœªçŸ¥é”™è¯¯')}"
             )
-    
+        
     except HTTPException:
         raise
     except Exception as e:
+        logger.error(f"æ–‡ä¹¦å¤„ç†å¤±è´¥: {str(e)}")
         raise HTTPException(
             status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
-            detail=f"æ–‡ä¹¦ç”ŸæˆæœåŠ¡å¼‚å¸¸: {str(e)}"
-        )
-
-
-@router.post("/feedback")
-async def submit_document_feedback(
-    feedback: DocumentUsageFeedback,
-    current_user: Dict[str, Any] = Depends(get_current_user),
-    db: AsyncSession = Depends(get_db)
-):
-    """
-    æäº¤æ–‡ä¹¦ä½¿ç”¨åé¦ˆ
-    ç”¨äºæ”¹è¿›æ–‡ä¹¦è´¨é‡å’ŒæˆåŠŸç‡ç»Ÿè®¡
-    """
-    try:
-        from sqlalchemy import text
-        
-        # æ›´æ–°ä½¿ç”¨å†å²è®°å½•
-        update_sql = text("""
-            UPDATE document_usage_history 
-            SET was_successful = :success,
-                client_response = :response,
-                modifications_made = :modifications,
-                final_content = :final_content,
-                completed_at = CURRENT_TIMESTAMP
-            WHERE document_id = :doc_id 
-                AND user_id = :user_id
-                AND completed_at IS NULL
-            ORDER BY used_at DESC
-            LIMIT 1
-        """)
-        
-        await db.execute(update_sql, {
-            'success': feedback.was_successful,
-            'response': feedback.client_response,
-            'modifications': feedback.modifications_made,
-            'final_content': feedback.final_content,
-            'doc_id': feedback.document_id,
-            'user_id': current_user["id"]
-        })
-        
-        # é‡æ–°è®¡ç®—æ–‡ä¹¦æˆåŠŸç‡
-        calculate_sql = text("""
-            UPDATE document_library 
-            SET success_rate = (
-                SELECT COALESCE(
-                    (COUNT(CASE WHEN was_successful = true THEN 1 END) * 100.0 / NULLIF(COUNT(*), 0)),
-                    0
-                )
-                FROM document_usage_history 
-                WHERE document_id = :doc_id 
-                AND was_successful IS NOT NULL
-            )
-            WHERE id = :doc_id
-        """)
-        
-        await db.execute(calculate_sql, {'doc_id': feedback.document_id})
-        await db.commit()
-        
-        return {
-            "success": True,
-            "message": "åé¦ˆæäº¤æˆåŠŸï¼Œè°¢è°¢æ‚¨çš„åé¦ˆï¼"
-        }
-    
-    except Exception as e:
-        await db.rollback()
-        raise HTTPException(
-            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
-            detail=f"æäº¤åé¦ˆå¤±è´¥: {str(e)}"
+            detail=f"æ–‡ä¹¦å¤„ç†å¤±è´¥: {str(e)}"
         )
 
 
-@router.get("/stats")
-async def get_document_library_stats(
-    current_user: Dict[str, Any] = Depends(get_current_user),
-    db: AsyncSession = Depends(get_db)
-):
-    """è·å–ç”¨æˆ·çš„æ–‡ä¹¦åº“ç»Ÿè®¡ä¿¡æ¯"""
-    try:
-        config_service = SystemConfigService(db)
-        doc_service = DocumentLibraryService(config_service)
-        
-        stats = await doc_service.get_document_library_stats(db, current_user["id"])
-        
-        return stats
-    
-    except Exception as e:
-        raise HTTPException(
-            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
-            detail=f"è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥: {str(e)}"
-        )
-
-
-@router.get("/library")
-async def get_user_documents(
-    document_type: Optional[str] = None,
-    limit: int = 20,
-    offset: int = 0,
-    current_user: Dict[str, Any] = Depends(get_current_user),
-    db: AsyncSession = Depends(get_db)
-):
-    """è·å–ç”¨æˆ·çš„æ–‡ä¹¦åº“åˆ—è¡¨"""
-    try:
-        from sqlalchemy import text
-        
-        # æ„å»ºæŸ¥è¯¢æ¡ä»¶
-        where_conditions = ["created_by = :user_id", "is_active = true"]
-        params = {"user_id": current_user["id"], "limit": limit, "offset": offset}
-        
-        if document_type:
-            where_conditions.append("document_type = :doc_type")
-            params["doc_type"] = document_type
-        
-        query = text(f"""
-            SELECT 
-                id, document_type, document_title, 
-                usage_count, success_rate, ai_quality_score,
-                template_tags, case_keywords,
-                created_at, last_used_at
-            FROM document_library
-            WHERE {' AND '.join(where_conditions)}
-            ORDER BY usage_count DESC, success_rate DESC, created_at DESC
-            LIMIT :limit OFFSET :offset
-        """)
-        
-        result = await db.execute(query, params)
-        documents = []
-        
-        for row in result:
-            documents.append({
-                "id": str(row[0]),
-                "document_type": row[1],
-                "document_title": row[2],
-                "usage_count": row[3],
-                "success_rate": float(row[4]) if row[4] else 0,
-                "quality_score": row[5],
-                "template_tags": row[6] or [],
-                "case_keywords": row[7] or [],
-                "created_at": row[8].isoformat() if row[8] else None,
-                "last_used_at": row[9].isoformat() if row[9] else None
-            })
-        
-        # è·å–æ€»æ•°
-        count_query = text(f"""
-            SELECT COUNT(*) FROM document_library
-            WHERE {' AND '.join(where_conditions[:-2])}  -- æ’é™¤limitå’Œoffsetç›¸å…³æ¡ä»¶
-        """)
-        count_params = {k: v for k, v in params.items() if k not in ['limit', 'offset']}
-        total_result = await db.execute(count_query, count_params)
-        total_count = total_result.scalar()
-        
-        return {
-            "success": True,
-            "documents": documents,
-            "total_count": total_count,
-            "has_more": (offset + limit) < total_count
-        }
-    
-    except Exception as e:
-        raise HTTPException(
-            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
-            detail=f"è·å–æ–‡ä¹¦åº“åˆ—è¡¨å¤±è´¥: {str(e)}"
-        )
-
-
-@router.get("/{document_id}")
-async def get_document_detail(
-    document_id: UUID,
-    current_user: Dict[str, Any] = Depends(get_current_user),
-    db: AsyncSession = Depends(get_db)
-):
-    """è·å–æ–‡ä¹¦è¯¦ç»†å†…å®¹"""
-    try:
-        from sqlalchemy import text
-        
-        query = text("""
-            SELECT 
-                id, document_type, document_title, document_content,
-                usage_count, success_rate, ai_quality_score,
-                template_tags, case_keywords, generation_method,
-                created_at, updated_at, last_used_at
-            FROM document_library
-            WHERE id = :doc_id AND created_by = :user_id AND is_active = true
-        """)
-        
-        result = await db.execute(query, {
-            'doc_id': document_id,
-            'user_id': current_user["id"]
-        })
-        
-        row = result.fetchone()
-        if not row:
-            raise HTTPException(
-                status_code=status.HTTP_404_NOT_FOUND,
-                detail="æ–‡ä¹¦ä¸å­˜åœ¨æˆ–æ— æƒè®¿é—®"
-            )
-        
-        return {
-            "success": True,
-            "document": {
-                "id": str(row[0]),
-                "document_type": row[1],
-                "document_title": row[2],
-                "document_content": row[3],
-                "usage_count": row[4],
-                "success_rate": float(row[5]) if row[5] else 0,
-                "quality_score": row[6],
-                "template_tags": row[7] or [],
-                "case_keywords": row[8] or [],
-                "generation_method": row[9],
-                "created_at": row[10].isoformat() if row[10] else None,
-                "updated_at": row[11].isoformat() if row[11] else None,
-                "last_used_at": row[12].isoformat() if row[12] else None
+@router.get("/templates")
+async def get_document_templates():
+    """è·å–å¯ç”¨çš„æ–‡ä¹¦æ¨¡æ¿"""
+    return {
+        "success": True,
+        "templates": [
+            {
+                "type": "lawyer_letter",
+                "name": "å‚¬æ”¶å¾‹å¸ˆå‡½",
+                "description": "ç”¨äºå€ºåŠ¡å‚¬æ”¶çš„å¾‹å¸ˆå‡½æ¨¡æ¿",
+                "available": True
+            },
+            {
+                "type": "debt_collection",
+                "name": "å€ºåŠ¡å‚¬æ”¶é€šçŸ¥ä¹¦",
+                "description": "æ­£å¼çš„å€ºåŠ¡å‚¬æ”¶é€šçŸ¥ä¹¦",
+                "available": False
             }
-        }
-    
-    except HTTPException:
-        raise
-    except Exception as e:
-        raise HTTPException(
-            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
-            detail=f"è·å–æ–‡ä¹¦è¯¦æƒ…å¤±è´¥: {str(e)}"
-        )
\ No newline at end of file
+        ]
+    }
+
+
+@router.get("/health")
+async def health_check():
+    """å¥åº·æ£€æŸ¥"""
+    return {
+        "success": True,
+        "service": "document_library_simple",
+        "status": "healthy",
+        "message": "ç®€åŒ–æ–‡ä¹¦æœåŠ¡è¿è¡Œæ­£å¸¸"
+    }
\ No newline at end of file
diff --git a/backend/app/api/v1/endpoints/document_library_backup.py b/backend/app/api/v1/endpoints/document_library_backup.py
new file mode 100644
index 0000000..0174d3d
--- /dev/null
+++ b/backend/app/api/v1/endpoints/document_library_backup.py
@@ -0,0 +1,321 @@
+"""
+æ–‡ä¹¦åº“ç®¡ç†APIç«¯ç‚¹
+"""
+
+from typing import Dict, Any, Optional
+from fastapi import APIRouter, Depends, HTTPException, status
+from pydantic import BaseModel
+from uuid import UUID
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from app.core.database import get_db
+from app.core.deps import get_current_user
+from app.services.document_library_service import DocumentLibraryService
+from app.services.config_service import SystemConfigService
+from app.services.ai_service import AIDocumentService
+
+router = APIRouter()
+
+
+class DocumentGenerationRequest(BaseModel):
+    task_id: Optional[str] = None
+    case_id: Optional[UUID] = None
+    task_type: str = "general_legal"
+    task_title: str = ""
+    task_description: str = ""
+    amount: Optional[float] = None
+    overdue_days: Optional[int] = None
+    force_regenerate: bool = False
+
+
+class DocumentUsageFeedback(BaseModel):
+    document_id: UUID
+    was_successful: bool
+    client_response: Optional[str] = None
+    modifications_made: Optional[str] = None
+    final_content: Optional[str] = None
+
+
+@router.post("/generate")
+async def generate_document(
+    request: DocumentGenerationRequest,
+    current_user: Dict[str, Any] = Depends(get_current_user),
+    db: AsyncSession = Depends(get_db)
+):
+    """
+    ç”Ÿæˆæˆ–è·å–æ–‡ä¹¦å†…å®¹
+    ä¼˜å…ˆä»åº“ä¸­è·å–ï¼Œå¦‚æ— åˆé€‚æ–‡ä¹¦åˆ™ç”Ÿæˆæ–°çš„
+    """
+    try:
+        # åˆå§‹åŒ–æœåŠ¡
+        config_service = SystemConfigService(db)
+        ai_service = AIDocumentService(config_service)
+        doc_service = DocumentLibraryService(config_service, ai_service)
+        
+        # æ„å»ºä»»åŠ¡ä¿¡æ¯
+        task_info = {
+            'taskId': request.task_id,
+            'taskType': request.task_type,
+            'title': request.task_title,
+            'description': request.task_description,
+            'amount': request.amount or 0,
+            'overdue_days': request.overdue_days or 0
+        }
+        
+        # è·å–æˆ–ç”Ÿæˆæ–‡ä¹¦
+        result = await doc_service.get_or_generate_document(
+            db=db,
+            task_info=task_info,
+            user_id=current_user["id"],
+            case_id=request.case_id,
+            force_regenerate=request.force_regenerate
+        )
+        
+        if result['success']:
+            return {
+                "success": True,
+                "document_content": result['document_content'],
+                "document_title": result['document_title'],
+                "source": result['source'],
+                "document_id": str(result['document_id']),
+                "usage_stats": {
+                    "usage_count": result.get('usage_count', 0),
+                    "success_rate": result.get('success_rate', 0),
+                    "quality_score": result.get('quality_score', 0)
+                },
+                "message": result.get('message', 'æ–‡ä¹¦ç”ŸæˆæˆåŠŸ')
+            }
+        else:
+            raise HTTPException(
+                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+                detail=result.get('error', 'æ–‡ä¹¦ç”Ÿæˆå¤±è´¥')
+            )
+    
+    except HTTPException:
+        raise
+    except Exception as e:
+        raise HTTPException(
+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+            detail=f"æ–‡ä¹¦ç”ŸæˆæœåŠ¡å¼‚å¸¸: {str(e)}"
+        )
+
+
+@router.post("/feedback")
+async def submit_document_feedback(
+    feedback: DocumentUsageFeedback,
+    current_user: Dict[str, Any] = Depends(get_current_user),
+    db: AsyncSession = Depends(get_db)
+):
+    """
+    æäº¤æ–‡ä¹¦ä½¿ç”¨åé¦ˆ
+    ç”¨äºæ”¹è¿›æ–‡ä¹¦è´¨é‡å’ŒæˆåŠŸç‡ç»Ÿè®¡
+    """
+    try:
+        from sqlalchemy import text
+        
+        # æ›´æ–°ä½¿ç”¨å†å²è®°å½•
+        update_sql = text("""
+            UPDATE document_usage_history 
+            SET was_successful = :success,
+                client_response = :response,
+                modifications_made = :modifications,
+                final_content = :final_content,
+                completed_at = CURRENT_TIMESTAMP
+            WHERE document_id = :doc_id 
+                AND user_id = :user_id
+                AND completed_at IS NULL
+            ORDER BY used_at DESC
+            LIMIT 1
+        """)
+        
+        await db.execute(update_sql, {
+            'success': feedback.was_successful,
+            'response': feedback.client_response,
+            'modifications': feedback.modifications_made,
+            'final_content': feedback.final_content,
+            'doc_id': feedback.document_id,
+            'user_id': current_user["id"]
+        })
+        
+        # é‡æ–°è®¡ç®—æ–‡ä¹¦æˆåŠŸç‡
+        calculate_sql = text("""
+            UPDATE document_library 
+            SET success_rate = (
+                SELECT COALESCE(
+                    (COUNT(CASE WHEN was_successful = true THEN 1 END) * 100.0 / NULLIF(COUNT(*), 0)),
+                    0
+                )
+                FROM document_usage_history 
+                WHERE document_id = :doc_id 
+                AND was_successful IS NOT NULL
+            )
+            WHERE id = :doc_id
+        """)
+        
+        await db.execute(calculate_sql, {'doc_id': feedback.document_id})
+        await db.commit()
+        
+        return {
+            "success": True,
+            "message": "åé¦ˆæäº¤æˆåŠŸï¼Œè°¢è°¢æ‚¨çš„åé¦ˆï¼"
+        }
+    
+    except Exception as e:
+        await db.rollback()
+        raise HTTPException(
+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+            detail=f"æäº¤åé¦ˆå¤±è´¥: {str(e)}"
+        )
+
+
+@router.get("/stats")
+async def get_document_library_stats(
+    current_user: Dict[str, Any] = Depends(get_current_user),
+    db: AsyncSession = Depends(get_db)
+):
+    """è·å–ç”¨æˆ·çš„æ–‡ä¹¦åº“ç»Ÿè®¡ä¿¡æ¯"""
+    try:
+        config_service = SystemConfigService(db)
+        doc_service = DocumentLibraryService(config_service)
+        
+        stats = await doc_service.get_document_library_stats(db, current_user["id"])
+        
+        return stats
+    
+    except Exception as e:
+        raise HTTPException(
+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+            detail=f"è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥: {str(e)}"
+        )
+
+
+@router.get("/library")
+async def get_user_documents(
+    document_type: Optional[str] = None,
+    limit: int = 20,
+    offset: int = 0,
+    current_user: Dict[str, Any] = Depends(get_current_user),
+    db: AsyncSession = Depends(get_db)
+):
+    """è·å–ç”¨æˆ·çš„æ–‡ä¹¦åº“åˆ—è¡¨"""
+    try:
+        from sqlalchemy import text
+        
+        # æ„å»ºæŸ¥è¯¢æ¡ä»¶
+        where_conditions = ["created_by = :user_id", "is_active = true"]
+        params = {"user_id": current_user["id"], "limit": limit, "offset": offset}
+        
+        if document_type:
+            where_conditions.append("document_type = :doc_type")
+            params["doc_type"] = document_type
+        
+        query = text(f"""
+            SELECT 
+                id, document_type, document_title, 
+                usage_count, success_rate, ai_quality_score,
+                template_tags, case_keywords,
+                created_at, last_used_at
+            FROM document_library
+            WHERE {' AND '.join(where_conditions)}
+            ORDER BY usage_count DESC, success_rate DESC, created_at DESC
+            LIMIT :limit OFFSET :offset
+        """)
+        
+        result = await db.execute(query, params)
+        documents = []
+        
+        for row in result:
+            documents.append({
+                "id": str(row[0]),
+                "document_type": row[1],
+                "document_title": row[2],
+                "usage_count": row[3],
+                "success_rate": float(row[4]) if row[4] else 0,
+                "quality_score": row[5],
+                "template_tags": row[6] or [],
+                "case_keywords": row[7] or [],
+                "created_at": row[8].isoformat() if row[8] else None,
+                "last_used_at": row[9].isoformat() if row[9] else None
+            })
+        
+        # è·å–æ€»æ•°
+        count_query = text(f"""
+            SELECT COUNT(*) FROM document_library
+            WHERE {' AND '.join(where_conditions[:-2])}  -- æ’é™¤limitå’Œoffsetç›¸å…³æ¡ä»¶
+        """)
+        count_params = {k: v for k, v in params.items() if k not in ['limit', 'offset']}
+        total_result = await db.execute(count_query, count_params)
+        total_count = total_result.scalar()
+        
+        return {
+            "success": True,
+            "documents": documents,
+            "total_count": total_count,
+            "has_more": (offset + limit) < total_count
+        }
+    
+    except Exception as e:
+        raise HTTPException(
+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+            detail=f"è·å–æ–‡ä¹¦åº“åˆ—è¡¨å¤±è´¥: {str(e)}"
+        )
+
+
+@router.get("/{document_id}")
+async def get_document_detail(
+    document_id: UUID,
+    current_user: Dict[str, Any] = Depends(get_current_user),
+    db: AsyncSession = Depends(get_db)
+):
+    """è·å–æ–‡ä¹¦è¯¦ç»†å†…å®¹"""
+    try:
+        from sqlalchemy import text
+        
+        query = text("""
+            SELECT 
+                id, document_type, document_title, document_content,
+                usage_count, success_rate, ai_quality_score,
+                template_tags, case_keywords, generation_method,
+                created_at, updated_at, last_used_at
+            FROM document_library
+            WHERE id = :doc_id AND created_by = :user_id AND is_active = true
+        """)
+        
+        result = await db.execute(query, {
+            'doc_id': document_id,
+            'user_id': current_user["id"]
+        })
+        
+        row = result.fetchone()
+        if not row:
+            raise HTTPException(
+                status_code=status.HTTP_404_NOT_FOUND,
+                detail="æ–‡ä¹¦ä¸å­˜åœ¨æˆ–æ— æƒè®¿é—®"
+            )
+        
+        return {
+            "success": True,
+            "document": {
+                "id": str(row[0]),
+                "document_type": row[1],
+                "document_title": row[2],
+                "document_content": row[3],
+                "usage_count": row[4],
+                "success_rate": float(row[5]) if row[5] else 0,
+                "quality_score": row[6],
+                "template_tags": row[7] or [],
+                "case_keywords": row[8] or [],
+                "generation_method": row[9],
+                "created_at": row[10].isoformat() if row[10] else None,
+                "updated_at": row[11].isoformat() if row[11] else None,
+                "last_used_at": row[12].isoformat() if row[12] else None
+            }
+        }
+    
+    except HTTPException:
+        raise
+    except Exception as e:
+        raise HTTPException(
+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+            detail=f"è·å–æ–‡ä¹¦è¯¦æƒ…å¤±è´¥: {str(e)}"
+        )
\ No newline at end of file
diff --git a/backend/app/api/v1/endpoints/document_library_new.py b/backend/app/api/v1/endpoints/document_library_new.py
new file mode 100644
index 0000000..850af47
--- /dev/null
+++ b/backend/app/api/v1/endpoints/document_library_new.py
@@ -0,0 +1,147 @@
+"""
+ç®€åŒ–æ–‡ä¹¦åº“APIç«¯ç‚¹
+ä½¿ç”¨æ¨¡æ¿ç”Ÿæˆï¼Œé¿å…æ•°æ®åº“ä¾èµ–
+"""
+
+from fastapi import APIRouter, Depends, HTTPException, status
+from sqlalchemy.ext.asyncio import AsyncSession
+from typing import Dict, Any, Optional
+from pydantic import BaseModel
+import logging
+
+from app.core.database import get_db
+from app.core.deps import get_current_user
+from app.services.simple_document_service import SimpleDocumentService
+from app.services.user_service import UserService
+
+logger = logging.getLogger(__name__)
+router = APIRouter()
+
+
+class DocumentGenerationRequest(BaseModel):
+    task_id: str
+    task_type: str = "lawyer_letter"
+    task_title: str
+    task_description: str
+    amount: Optional[float] = 0
+    overdue_days: Optional[int] = 0
+    force_regenerate: bool = False
+
+
+@router.post("/generate")
+async def generate_document(
+    request: DocumentGenerationRequest,
+    current_user: Dict[str, Any] = Depends(get_current_user),
+    db: AsyncSession = Depends(get_db)
+):
+    """
+    ç”Ÿæˆæ–‡ä¹¦å†…å®¹ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
+    """
+    try:
+        # åˆå§‹åŒ–æœåŠ¡
+        doc_service = SimpleDocumentService()
+        user_service = UserService(db)
+        
+        # æ„å»ºä»»åŠ¡ä¿¡æ¯
+        task_info = {
+            'taskId': request.task_id,
+            'taskType': request.task_type,
+            'title': request.task_title,
+            'description': request.task_description,
+            'amount': request.amount or 0,
+            'overdue_days': request.overdue_days or 0,
+            'budget': request.amount or 0
+        }
+        
+        # è·å–å¾‹å¸ˆä¿¡æ¯
+        try:
+            lawyer_user = await user_service.get_user_by_id(current_user["id"])
+            lawyer_profile = await user_service.get_user_profile(current_user["id"])
+            
+            lawyer_info = {
+                'name': lawyer_profile.full_name if lawyer_profile and lawyer_profile.full_name else lawyer_user.username if lawyer_user else 'å¼ å¾‹å¸ˆ',
+                'license_number': getattr(lawyer_profile, 'license_number', None) if lawyer_profile else None or '11010201234567890',
+                'phone': lawyer_user.phone_number if lawyer_user and lawyer_user.phone_number else '138-0000-0000',
+                'email': lawyer_user.email if lawyer_user else 'lawyer@lawfirm.com'
+            }
+        except Exception as e:
+            logger.warning(f"è·å–å¾‹å¸ˆä¿¡æ¯å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ä¿¡æ¯: {str(e)}")
+            lawyer_info = doc_service.get_default_lawyer_info()
+        
+        # ä½¿ç”¨é»˜è®¤å¾‹æ‰€ä¿¡æ¯ï¼ˆå®é™…é¡¹ç›®ä¸­åº”ä»é…ç½®æˆ–æ•°æ®åº“è·å–ï¼‰
+        law_firm_info = doc_service.get_default_law_firm_info()
+        
+        # ç”Ÿæˆæ–‡ä¹¦
+        result = await doc_service.generate_lawyer_letter(
+            task_info=task_info,
+            lawyer_info=lawyer_info,
+            law_firm_info=law_firm_info
+        )
+        
+        if result.get('success'):
+            return {
+                "success": True,
+                "document": {
+                    "title": result.get('title'),
+                    "content": result.get('content'),
+                    "document_type": result.get('document_type', 'lawyer_letter'),
+                    "quality_score": result.get('quality_score', 95),
+                    "generation_method": result.get('generation_method', 'template'),
+                    "lawyer_info": {
+                        "name": lawyer_info['name'],
+                        "phone": lawyer_info['phone']
+                    },
+                    "law_firm_info": {
+                        "name": law_firm_info['name'],
+                        "address": law_firm_info['address']
+                    }
+                },
+                "message": "æ–‡ä¹¦ç”ŸæˆæˆåŠŸ"
+            }
+        else:
+            raise HTTPException(
+                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+                detail=f"æ–‡ä¹¦ç”Ÿæˆå¤±è´¥: {result.get('error', 'æœªçŸ¥é”™è¯¯')}"
+            )
+        
+    except HTTPException:
+        raise
+    except Exception as e:
+        logger.error(f"æ–‡ä¹¦å¤„ç†å¤±è´¥: {str(e)}")
+        raise HTTPException(
+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
+            detail=f"æ–‡ä¹¦å¤„ç†å¤±è´¥: {str(e)}"
+        )
+
+
+@router.get("/templates")
+async def get_document_templates():
+    """è·å–å¯ç”¨çš„æ–‡ä¹¦æ¨¡æ¿"""
+    return {
+        "success": True,
+        "templates": [
+            {
+                "type": "lawyer_letter",
+                "name": "å‚¬æ”¶å¾‹å¸ˆå‡½",
+                "description": "ç”¨äºå€ºåŠ¡å‚¬æ”¶çš„å¾‹å¸ˆå‡½æ¨¡æ¿",
+                "available": True
+            },
+            {
+                "type": "debt_collection",
+                "name": "å€ºåŠ¡å‚¬æ”¶é€šçŸ¥ä¹¦",
+                "description": "æ­£å¼çš„å€ºåŠ¡å‚¬æ”¶é€šçŸ¥ä¹¦",
+                "available": False
+            }
+        ]
+    }
+
+
+@router.get("/health")
+async def health_check():
+    """å¥åº·æ£€æŸ¥"""
+    return {
+        "success": True,
+        "service": "document_library_simple",
+        "status": "healthy",
+        "message": "ç®€åŒ–æ–‡ä¹¦æœåŠ¡è¿è¡Œæ­£å¸¸"
+    }
\ No newline at end of file
-- 
2.34.1

